---
title: fperl
---

<script src="https://kit.fontawesome.com/76d9b5d027.js" crossorigin="anonymous"></script>

![fperl-banner](../../assets/fperl-home-banners.gif)
#fperl-ebook | Programming Entrance
###### Author: [Yatsugi Saiba](../../about/me.md)

---

## Bagian I: Introductions
### **I. Bacaan ini sebenarnya untuk siapa?**

Saat membuka page ini, kamu mungkin belum menyadari bahwa:

"Belajar Perl bisa menjadi langkah awal untuk memahami cara kerja komputer, terutama bagi mereka yang ingin mulai mengotomatisasi tugas-tugas sehari-hari. Page ini dirancang untuk siapa saja yang ingin memulai pemrograman, tanpa memerlukan latar belakang teknis yang mendalam."

Atau mungkin kamu langsung membaca halaman ini tanpa melihat pengantar sebelumnya. Tapi sekarang, setelah kamu ada di sini, mungkin kamu bertanya: **siapa sebenarnya yang akan mendapatkan manfaat dari page ini?** Mari aku jelaskan dengan jelas:

**Page ini untuk siapa saja yang ingin belajar mengendalikan komputer.**

Mungkin kamu pernah mencoba belajar pemrograman sebelumnya tetapi merasa kesulitan. Mungkin juga ini pertama kalinya kamu menjajal dunia kode. Kamu mungkin sudah membaca panduan pemrograman yang terlalu teknis, yang membuatmu merasa jauh dari tujuanmu. Tapi sekarang, kamu kembali mencoba, dan itu adalah langkah besar. Aku berterima kasih karena kamu memberiku kesempatan untuk membantu.

Jika satu-satunya pengalamanmu dengan "kode" hanyalah menggunakan perintah `find` di terminal untuk mencari file tertentu di komputermu, itu sudah cukup. Dan kalaupun kamu tidak tahu apa maksudku dengan contoh itu, tenang saja, tidak perlu khawatir.

Bahkan jika pengalamanmu dengan teknologi hanya sebatas mengatur folder di email secara otomatis, atau menambahkan aturan pada file manajemen, itu pun bisa disebut sebagai bentuk pemrograman. Kamu sudah memberi perintah pada komputer, dan ia menjalankannya.

Sekarang, kamu membaca page ini di sebuah perangkat, yang sudah merupakan titik awal yang bagus. Kamu mungkin sudah tahu cara menggunakan browser untuk membuka situs web atau mencari informasi. Ini adalah permulaan yang tepat, karena inti dari pemrograman adalah memberi komputer instruksi agar bisa melakukan lebih banyak hal untukmu, secara otomatis. Dan itulah yang akan kita pelajari di sini.

Jadi, mari kita melangkah lebih jauh dan memahami apa itu **Perl**—bahasa yang fleksibel, kuat, dan sempurna untuk tugas-tugas seperti manipulasi teks, otomasi, dan banyak lagi.

---

### **II. Perl? Bukankah itu sejenis bebatuan?**

Perl sebagai bahasa pemrograman sangat berbeda dari istilah "perl" yang dalam bahasa Inggris bisa berarti:

Sesuatu yang seringkali dianggap sebagai batu mulia atau merek camilan yang menggugah selera.

Dan untuk varian bahasa pemrograman, ia didefinisikan sebagai:

Perl adalah bahasa pemrograman yang fleksibel dan kuat, sering digunakan untuk manipulasi teks, otomasi tugas, dan pengembangan aplikasi web.

Penjelasan pertama tampaknya ditulis dengan bahasa yang mudah dipahami. Kamu bisa membaca setiap kata dan memahaminya dengan baik. Sementara penjelasan kedua, bisa jadi adalah deretan kata yang mungkin diungkapkan oleh teman nerd-mu setelah menyesuaikan kacamatanya dan mereka mungkin akan memulai kalimat dengan "Sebenarnya [berhenti sejenak untuk efek dramatis]".

Tentu saja, beberapa kata mungkin kamu pahami, tetapi yang lainnya mungkin terdengar seperti jargon yang membingungkan.

Apa sebenarnya arti "fleksibel"? Apakah itu berarti bisa digunakan untuk banyak hal? Tentu saja, kita berharap itu bisa digunakan untuk berbagai tujuan! Jika tidak, untuk apa kita membahasnya? Lebih baik tutup halaman ini sekarang. Tidak ada gunanya menggunakan bahasa pemrograman yang tidak fleksibel!

Kuat? Apa maksudnya? Apakah itu berarti bisa melakukan banyak hal sekaligus? Mengapa itu penting?

Lalu, apa itu "manipulasi teks"? Apakah itu seperti mengubah kata-kata dalam sebuah dokumen?

Selanjutnya, apa itu aplikasi web? Apakah itu seperti website yang kita buka di browser?

Kamu mungkin merasa bingung dengan istilah-istilah ini, dan tidak ada salahnya jika kamu merasa demikian. Penjelasan ini sepertinya ditulis oleh orang-orang yang sudah terbiasa dengan istilah-istilah teknis dan mungkin tidak terlalu memikirkan siapa yang akan membacanya. Mereka mungkin membaca penjelasan ini sambil mengangguk paham dan berkata, "Ahh, ya, itu benar dan jelas." Tapi bagi kamu yang baru saja memulai, mari kita jelaskan dengan cara yang lebih bersahabat!

#### Penjelasan yang Ramah untuk Manusia

Jangan khawatir tentang penjelasan teknis mengenai apa itu Perl. Mari kita coba ini:

Perl adalah bahasa pemrograman yang digunakan oleh manusia untuk memberi tahu komputer melakukan berbagai tindakan.

Itu adalah penjelasan yang cukup baik. Aku bisa bilang begitu karena aku yang menulis ini. Aku menulis apa pun yang aku mau, dan kamu membaca—begitulah cara kerjanya.

Penjelasan baru ini menggunakan kata-kata sederhana untuk menjelaskan apa yang bisa kamu lakukan dengan Perl. Ini tidak mencakup fitur-fitur rumit menggunakan istilah seperti "fleksibel" dan "kuat," dan tentu saja tidak menyebutkan jargon teknis yang membingungkan.

Penjelasan ini cukup bagus sehingga bisa digunakan untuk menjelaskan bahasa pemrograman apa pun. Mungkin terlalu umum, seperti makanan kemasan murah yang kamu temukan di rak bawah supermarket. Meskipun cukup untuk mengenyangkan, mungkin tidak begitu memuaskan perutmu.

Oke, mari kita perbaiki! Berikut adalah Versi Dua Penjelasan Sederhana Tentang Perl:

Perl adalah bahasa pemrograman yang sangat menyenangkan dan mudah digunakan. Dengan Perl, kamu bisa menulis program yang mudah dipahami oleh manusia dan komputer. Menulis kode Perl itu menyenangkan.

Oh ya! Ini jauh lebih baik. Menarik perhatian orang-orang di sekitarmu. "Kesenangan? Kami suka kesenangan!", seru mereka. Kemudian mereka berkata: "Kami ingin melihat beberapa kode Perl! Cukup bicara!". Uh oh, kerumunan semakin bersemangat. Mungkin aku harus memberikan apa yang mereka inginkan.

---
## Bagian Dua: And away we go
#### 1. Memuaskan Kerumunan dengan Kode

Kerumunan telah duduk menyimak bagian terbaik dari sebuah bab (setidaknya) menyerap semua yang telah kita bicarakan. Tapi mereka sedikit gelisah karena kita sudah berbicara tentang bahasa pemrograman tanpa benar-benar melakukan pemrograman. Ya, itu sangat bisa dimengerti! Saya pun akan merasa jengkel jika saya bukan orang yang menulis buku ini. Saya tahu apa yang akan datang, tetapi mereka tidak.

Oke, mari kita coba memuaskan kerumunan. Berikut adalah beberapa kode:

```perl linenums="1"
print "Hello, World!\n";
```

Kerumunan terdiam. Tatapan mereka semakin tajam. Jurubicara mereka—yang mereka angkat saat saya berpikir tentang potongan kode ini—berkata (sambil merobek dinding keempat): "Itu hanya sekumpulan kata yang dikutip! Sama seperti yang saya katakan ini."

Kerumunan setuju.

Baiklah, kamu benar. Itu memang hanya kata-kata yang dikutip, tetapi kata-kata itu bisa dipahami oleh manusia dan komputer. Itu cukup keren. Yah, setidaknya saya menganggapnya begitu.

Kerumunan manusia di depan kita tahu kata-kata itu dan bahwa kata-kata itu memiliki makna dan membentuk kalimat yang bisa dimengerti. Komputer hanya tahu huruf atau simbol individu dalam kata-kata tersebut, dan tidak peduli bahwa kata-kata itu memiliki makna atau bahwa kata-kata tersebut membentuk kalimat yang dapat dimengerti. "Hal-hal itu hanya penting bagi manusia," pikirnya, tanpa mengakui gelombang pembelajaran mesin yang telah muncul baru-baru ini.

Ketika kita menyampaikan kalimat ini kepada kerumunan, mereka bisa dengan mudah mengulanginya kembali kepada kita. Untuk berbicara kepada komputer, kita perlu membuka prompt untuk bahasa tertentu yang ingin kita gunakan untuk berkomunikasi. Bahasa yang berbeda memiliki prompt yang berbeda. Kita tidak bisa hanya berbicara kepada komputer untuk memrogramnya. Belum saatnya, bagaimanapun.

##### Menginstal Perl

Mungkin kamu belum menginstal Perl di mesin kamu, Cara untuk memeriksa apakah Perl terinstal adalah dengan menjalankan perintah ini di terminalmu:

```bash 
perl -v
```

Jika perintah ini menampilkan sesuatu seperti ini:

```bash
This is perl 5, version 40, subversion 1 (v5.32.1) built for x86_64-linux-gnu-thread-multi
```

Maka itu berarti Perl telah terinstal dan kamu bisa melanjutkan. Jika muncul pesan seperti "command not found", maka kamu bisa melakukan penginstalan perl terlebih dahulu, ikuti instruksi dari [halaman ini](https://perl.org/get.html), sesuaikan dengan mesin yang kamu gunakan.

Dalam hal ini, kita ingin akan berbicara langsung dengan Perl, jadi kita bisa membuka prompt di terminalmu dengan perintah `re.pl`. Setelah prompt terbuka, kita bisa mengetik kode yang ingin kita jalankan, seperti misal `print "hello world!\n"` dan tekan Enter untuk menjalankannya.

kamu akan langsung melihat hasilnya di baris berikutnya seperti ini:

```bash
$ print "hello world!\n"
hello world!
1$ 
```

jika ingin keluar dari prompt `repl` perl, kita tinggal meng-input `exit` kemudian enter:

```bash
$ exit
```

dan prompt repl perl pun akan tertutup.

##### Prompt Perl dan Menjalankan Kode

Prompt ini memberi tahu kita bahwa komputer sekarang siap mendengarkan instruksi kita, menunggu dengan antusias. Mari kita berikan komputer kalimat kita lagi, tekan enter di akhir baris:

```perl linenums="1"
print "Hello, World!\n";
```

Setelah kita mengetik ini dan menekan Enter, komputer akan mengeksekusi perintah tersebut dan menampilkan hasilnya:

```bash
Hello, World!
```

Di sini, kita memberikan komputer instruksi yang terlihat seperti kalimat biasa. Itu karena itu memang kalimat biasa. Dalam terminologi pemrograman, kita menyebut koleksi simbol yang diapit tanda kutip ganda ini sebagai string. Lebih mudah untuk memikirkan string ini sebagai bagian-bagian kalimat yang terhubung oleh sebuah benang.

Komputer kemudian menerima string ini, menginterpretasikannya, dan memberi tahu kita bagaimana ia menginterpretasikan string tersebut. Dalam hal ini, komputer hanya mengulangi kalimat/string kita kembali kepada kita. Komputer bisa melakukan jauh lebih banyak dari itu, percayalah. Komputer tidak akan berguna jika hanya bisa mengulangi kata-kata kembali kepada kita.

Kerumunan sekarang mulai gelisah. Jadi far kita hanya menunjukkan satu baris kode. Dua kali, memang, tetapi masih hanya satu baris kode. Dan komputer mengharapkan kita untuk memberikan lebih banyak input.

##### Matematika!

Oke, jadi komputer bisa mengulangi hal-hal. Tapi apa lagi yang bisa dilakukannya? Bagaimana jika kita minta komputer melakukan beberapa matematika sederhana?

```perl linenums="1"
print 2 + 4, "\n";  # 6
print 3 - 6, "\n";  # -3
print 4 * 12345, "\n";  # 49380
print 1234 / 4 + 2 - 12 * 3, "\n";  # 274.5
```

Ini sedikit memuaskan kerumunan. Mereka adalah sekelompok yang sulit dipuaskan. Komputer sekarang tidak lagi hanya mengulang kata-kata yang kita input. Sebagai gantinya, ia menghitung persamaan matematika sederhana yang kita berikan, dan kemudian memberikan \ menghasilkan angka yang tepat. Jika kamu tidak yakin bahwa ini adalah angka yang benar, saya sarankan kamu mengambil pena dan kertas dan mencatatnya sendiri, atau gunakan kalkulator di ponselmu. Kamu akan menemukan bahwa Hitungan yang dilakukan komputer pastilah benar!.

Kerumunan menyadari bahwa Perl sekarang dapat melakukan lebih dari sekadar pengulangan sederhana. Perl juga bisa melakukan perhitungan! Kita telah menggunakan simbol `+`, `-`, `*`, dan `/` di sini, meminta komputer untuk menjumlah, mengurang, mengalikan, dan membagi, dalam urutan itu. Mungkin kamu berpikir untuk menggunakan `x` untuk mengalikan, tetapi itu memiliki arti yang berbeda seperti yang akan kita lihat nanti. Kamu harus menggunakan `*` saat ingin mengalikan sesuatu, karena itulah yang diharapkan Perl.

##### Apa yang Ingin Kita Capai dalam Buku Ini

Oke, sekarang setelah kerumunan terpuaskan, mari kita luangkan waktu untuk membahas apa yang akan dibahas dalam buku ini dan apa yang akan kamu dapatkan darinya.

Sebelas bab pertama akan membahas beberapa dasar Perl. Ya, itu terlihat banyak, tetapi sebagian besar bab ini cukup pendek; hanya beberapa halaman. Ini sekitar 50 halaman secara keseluruhan. Bab-bab ini akan membahas hal-hal yang harus kamu ketahui sebelum kamu bisa menulis program Perl yang cukup panjang, dan memberikanmu tur yang baik tentang bahasa ini. Bab-bab ini penting karena mereka akan membangun fondasi yang solid untuk pengalaman Perl-mu.

Bab 12 dan seterusnya akan fokus pada membangun program yang lebih besar menggunakan teknik-teknik yang telah kita pelajari di sebelas bab pertama. Kita akan menggabungkan hal-hal dari bab-bab sebelumnya dan menggunakannya bersama-sama, dan kita bahkan akan diperkenalkan kepada lebih banyak hal yang dapat dilakukan oleh bahasa Perl.

Di akhir setiap bab, akan ada serangkaian latihan (opsional) yang bisa kamu lakukan, menggunakan hal-hal yang telah kamu pelajari di bab tersebut. Saya sangat mendorongmu untuk mencobanya setidaknya. Jika kamu tidak dapat melakukannya, jangan khawatir. Coba lagi nanti.

Dengan semua yang dikatakan, mari kita terus melihat apa yang bisa Perl lakukan untuk kita, dimulai dengan membuat Perl mengingat hal-hal untuk kita.

##### Latihan

1. Buat Perl menghitung jumlah detik dalam sehari dengan mengalikan jam dalam sehari dua kali dengan 60. Berapa banyak detik dalam sehari?
2. Hitung rata-rata dari angka-angka ini: 4, 8, 15, 16, 23, dan 42.

Catatan: Kamu dapat menemukan solusi untuk semua latihan dalam buku ini di bagian solusi di bagian belakang buku ini.

---

#### 2. Sekarang, di mana saya meletakkan nilai itu?  

Kita sudah melihat bahwa Perl dapat menangani kata-kata dan angka dengan mudah. Tapi, apa lagi yang bisa dilakukan? Nah, Perl bisa mengingat hal-hal.

```perl linenums="1"
my $sentence = "Kalimat yang sangat panjang dan kompleks 
yang lebih baik tidak kita ulangi.";

my $score = 2 / 5 * 100;

my $x = "tidak untuk perkalian";
```

Selama kita membiarkan skrip ini berjalan, Perl akan mengingat bahwa `$sentence` adalah "Kalimat yang sangat panjang dan kompleks yang lebih baik tidak kita ulangi," `$score` adalah 40, dan `$x` adalah "tidak untuk perkalian." Di mana pun kita berada, kita bisa bertanya apa itu `$sentence`, `$score`, atau `$x`, dan Perl akan memberi tahu kita:

```perl linenums="1"
print $sentence;  # Kalimat yang sangat panjang dan kompleks yang lebih baik tidak kita ulangi.
print $score;     # 40
print $x;        # tidak untuk perkalian
```

`$sentence`, `$score`, dan `$x` di sini adalah variabel, dan mereka diberi nama khusus karena hal yang diingat komputer dengan nama tersebut dapat bervariasi. 

Kita bisa memberi tahu komputer untuk mengganti definisi sebuah variabel dengan yang lain. Ini sering disebut sebagai re-penugasan. Mari kita ganti (atau re-assign) definisi variabel `$sentence`:

```perl linenums="1"
$sentence = "Kalimat yang bahkan lebih panjang dan jauh lebih kompleks 
yang mungkin kita setujui untuk ulangi, jika suasana hati mengizinkan.";
```

Kemudian ketika kita bertanya kepada komputer apa itu `$sentence`, dia akan melupakan kalimat lama dan hanya akan tahu yang baru:

```perl linenums="1"
print $sentence;  # Kalimat yang bahkan lebih panjang dan jauh lebih kompleks 
                   # yang mungkin kita setujui untuk ulangi, jika suasana hati mengizinkan.
```

Sekarang orang-orang terlihat lebih ceria. Beberapa bahkan tersenyum! Bukankah itu luar biasa? Mari kita buat variabel lain bernama `$place`:

```perl linenums="1"
my $place = "Dunia";
```

Komputer sekarang akan mengingat bahwa `$place` adalah "Dunia." "Tapi apa gunanya hanya menetapkan variabel seperti ini? Mengapa membuat komputer mengingat sama sekali?" tanya Isodora (juru bicara).

Baiklah, Isodora berkata begitu. Ngomong-ngomong, kita sudah tahu bahwa nama juru bicara adalah Isodora, dan kita telah membuat beberapa variabel dalam otak kita sendiri: `$spokesperson = "Isodora"`. Wah. "Panggil saja saya Izzy," kata Isodora. Oke, kita akan -- mengubah variabel juru bicara kita: `$spokesperson = "Izzy"`.

Oke, Izzy benar. Kita harus melakukan sesuatu yang berarti dengan variabel ini. Gimana kalau ini?

```perl linenums="1"
print "Halo, $place!\n";  # Halo, Dunia!
```

Orang-orang pun bersorak. Ini adalah kekacauan! 

"Apa yang baru saja terjadi?" tanya Izzy. Tapi kamu, Pembaca Tercinta, sudah bertanya pertanyaan itu sebelumnya. Izzy tidak mendengar karena keramaian dan kekacauan yang tidak terhingga.

Apa sebenarnya karakter aneh di sekitar `$place` itu? Kamu bisa menganggapnya sebagai tempat penampung. Orang-orang yang lebih geeky mungkin menyebutnya interpolasi. Itu memberi tahu komputer bahwa kita ingin meletakkan variabel `$place` di sini, tepat setelah "Halo" dan spasi, dan tepat sebelum tanda seru.

##### Latihan
1. Jika kita menyimpan jumlah detik dalam satu hari menggunakan kode ini: `my $seconds = 86400;`, hitung menggunakan variabel tersebut berapa jam dalam 30 hari.
2. Buat variabel bernama `$name`, simpan string di dalamnya dan tempatkan nilai variabel tersebut dalam string lain.
3. Baris `5 / "empat"` menunjukkan kesalahan. Pikirkan mengapa kesalahan ini bisa terjadi.

---

#### 3. Daftar Menarik

Tapi, apa lagi yang bisa dilakukan Perl? Kita sudah melihat bahwa ia bisa menangani string dan persamaan matematika dengan mudah, serta bisa mengingat hal-hal, tetapi apa lagi? Nah, bagaimana jika kita memiliki daftar hal-hal yang ingin kita ingatkan kepada komputer? Dan kita ingin komputer mengingat daftar hal-hal ini dalam urutan tertentu?

Kita bisa melakukan ini dengan menetapkan setiap hal ke variabel unik:

```perl linenums="1"
my $first = "ikan";
my $second = "kornet";
my $third = "telur";
```

Tetapi kemudian kita harus ingat bahwa hal-hal yang kita inginkan disimpan dalam variabel `first`, `second`, dan `third`. Dan bagaimana jika kita — sebagai manusia — lupa posisi yang sudah kita capai?

```perl linenums="1"
my $fifth = "roti";
```

Bencana! Ini tidak bisa diterima.

Solusi yang lebih baik untuk membuat komputer mengingat daftar di Perl adalah dengan memberi tahu bahwa yang kita simpan adalah sebuah daftar. Untuk melakukan ini, kita membungkus daftar kita dalam tanda kurung siku (`[]`) dan memisahkan setiap item dalam daftar dengan koma:

```perl linenums="1"
my @shopping_list = ("ikan", "kornet", "telur", "roti");
```

Sama seperti kita perlu memulai dan mengakhiri string dengan tanda kutip ganda, kita perlu memulai dan mengakhiri daftar dengan tanda kurung siku (`[]`).

Komputer sekarang akan mengingat seluruh daftar belanja kita dalam satu variabel (`@shopping_list`), daripada mengingatnya di beberapa variabel. Sekarang kita memiliki satu tempat untuk melihat daftar belanja kita.

Kita bisa menggunakan lebih dari sekadar string ketika kita membuat daftar. Misalnya, katakanlah kita ingin memiliki daftar suhu terakhir (dalam derajat Celsius) dari lima hari terakhir. Kita bisa merepresentasikan data ini seperti ini:

```perl linenums="1"
my @temperatures = (15, 17, 19, 20, 20);
```

Sebenarnya, apa pun di Perl bisa menjadi item dalam sebuah daftar.

Izzy, yang terkesan dengan kemampuan Perl untuk menyimpan daftar apa pun yang diinginkannya, mulai mencatat nama-nama orang yang ada di kerumunan. Komputernya muncul entah dari mana, atau mungkin dari suatu tempat di kerumunan. Terlalu cepat untuk benar-benar diperhatikan. Dia mulai mencatat nama-nama, jarinya bergerak cepat di atas papan ketik:

```perl linenums="1"
my @those_who_are_assembled = (
    "Izzy",
    "Penulis",
    "Pembaca",
    "Juliet",
    "Mary",
    "Bobalina",
    "Charlie",
    "Charlie (tidak ada hubungan)"
);
```

Apakah kamu melihat apa yang Izzy lakukan di sana? 
Dia memulai sebuah daftar dalam satu baris dan kemudian melanjutkannya di baris-baris berikutnya. Ketika dia selesai dengan daftarnya, komputer kemudian mengambil semua baris, memprosesnya sebagai satu instruksi besar, dan memberikan kita daftar yang sudah selesai. Perl akan membiarkan kita menulis daftar dalam beberapa baris seperti ini, yang sangat berguna untuk meningkatkan keterbacaan!

Dan Izzy terus melanjutkan. Dia menghilang ke kerumunan tepat di sebelah kanan kita, dan entah bagaimana muncul kembali dalam beberapa detik di sebelah kiri kita. Ini terjadi meskipun kerumunan begitu padat. Hal yang menakjubkan. Dia kemudian bertanya: "Hei, Tuan Penulis, saya juga ingin melacak usia orang-orang agar saya bisa melakukan statistik tentang siapa saja yang hadir di sini. Oh, dan saya ingin melacak gender mereka juga. Tapi, sebuah daftar tampaknya tidak cocok untuk ini. Bagaimana saya bisa melakukannya?"

Nah Izzy, ada lebih dari satu cara untuk melakukannya. Jika semua yang ingin kamu lacak tentang seseorang hanya nama, usia, dan gender mereka, kamu bisa membuat setiap item dalam daftar menjadi daftar tersendiri:

```perl linenums="1"
my @those_who_are_assembled = (
    ["Izzy", "30an", "Perempuan"],
    ["Penulis", "30an", "Laki-laki"],
);
```

Daftar di dalam daftar ini akan disebut sub-daftar. Kamu kemudian harus ingat bahwa item pertama dalam setiap sub-daftar adalah nama, yang kedua adalah usia, dan yang ketiga adalah gender. Bagaimana jika kamu (atau orang lain yang menggunakan komputermu) lupa urutan dan mulai menambahkan orang dengan posisi usia dan gender yang tertukar?

```perl linenums="1"
my @those_who_are_assembled = (
    ["Izzy", "30an", "Perempuan"],
    # ... waktu berlalu ...
    ["Izzy yang Lebih Muda", "Perempuan", "20an"],
);
```

Kekacauan lagi! Kita membutuhkan cara yang lebih baik untuk menegakkan data apa yang kita kumpulkan untuk setiap orang. Kita membutuhkan struktur data yang lebih baik daripada daftar dalam daftar. Baca terus untuk menemukan struktur data yang dimaksud!

--- 

#### 4. Peta Menakjubkan

Di bab sebelumnya, Izzy mencoba melacak informasi tentang orang-orang yang berkumpul menggunakan beberapa daftar di dalam daftar lain:

```perl linenums="1"
my @those_who_are_assembled = (
    ["Izzy", "30ish", "Female"],
    # ... waktu berlalu ...
    ["Izzy the Younger", "Female", "20ish"],
);
```

Namun, seperti yang kita lihat di sini, urutan item dalam daftar bisa dimasukkan dengan salah karena kesalahan manusia. Kita membutuhkan sesuatu yang dapat membantu mencegah kesalahan manusia seperti ini, dan jika sesuatu itu bisa menunjukkan dengan jelas apa setiap item dalam daftar — dengan memberi nama — maka itu akan sangat membantu.

Untuk itu, kita bisa menggunakan hash. Seperti peta biasa, hash dalam Perl bisa memberi tahu kita di mana menemukan sesuatu, jika saja kita tahu di mana mencarinya.

Mari kita lihat bagaimana kita bisa mengumpulkan data satu orang menggunakan hash, menggunakan anggota acak dari kerumunan sebagai contoh:

```perl linenums="1"
my %person = ("name" => "Roberto", "age" => 56, "gender" => "Male");
```

Hash dimulai dengan `%` dan membungkus datanya di dalam kurung kurawal. Dalam hash, kita menyusun data menggunakan kunci dan nilai. Hal yang di sebelah kiri `=>` disebut kunci dan yang di sebelah kanan disebut nilai.

##### Kunci dan Nilai

Sama seperti pada peta kota atau jalur pejalan kaki, kunci di sini memberi tahu kita di mana menemukan nilai tertentu. Jika, misalnya, kita ingin tahu umur orang ini, kita bisa menggunakan kunci "age" untuk mengambil nilai tersebut. 

Anda mungkin menyadari bahwa komputer menerima hash kita dan mengembalikan kunci dalam urutan yang berbeda dari yang kita tentukan. Urutan kunci tidak penting dalam hash sama sekali, tidak seperti dalam daftar di mana urutannya penting. 

Misalnya, jika kita memiliki daftar seperti ini:

```perl linenums="1"
my @favourite_people = ("The Reader", "Izzy", ...);
```

Daftar ini menunjukkan bahwa "The Reader" adalah orang favorit ke-1, dan Izzy adalah yang kedua. Urutan di sini sangat penting. Untuk hash, tidak masalah dalam urutan kunci dan nilai yang sesuai karena hash akan tetap sama:

```perl linenums="1"
my %person = ("gender" => "Male", "age" => 56, "name" => "Roberto");
```

Posisi kunci "name" dalam hash tidak memiliki arti. Kunci untuk hash bisa dalam urutan apa pun.

Anda mungkin berpikir tentang bagaimana cara mengambil data dari hash setelah kita memasukkannya. Kita telah membahas tentang bagaimana "mengambil" nilai tersebut sebelumnya, tetapi belum melihat contohnya. Untuk mengakses nilai dari hash kita perlu mengetahui kunci yang sesuai. Setelah kita tahu kunci yang sesuai, kita bisa menggunakan `{}` untuk mengambil nilai dari hash. Pikirkan ini seperti penjepit yang mengambil nilai.

Jika kita ingin mengambil nilai "name" untuk `person`, kita bisa melakukan:

```perl linenums="1"
$person{"name"};
```

Dan jika kita ingin mendapatkan umur, kita akan menggunakan kunci "age":

```perl linenums="1"
$person{"age"};
```

Izzy mengangguk setuju. Dia suka hash. Sekarang Izzy bisa mengetahui data yang tepat yang kita kumpulkan tentang orang-orang yang berkumpul, tanpa khawatir tentang bagaimana data diurutkan, dan kemudian menggunakannya di kemudian hari.

Untuk mengumpulkan data tentang semua orang yang berkumpul di sini, kita bisa membuat daftar hash:

```perl linenums="1"
my @those_who_are_assembled = (
    {"name" => "Izzy", "age" => "30ish", "gender" => "Female"},
    {"name" => "The Author", "age" => "30ish", "gender" => "Male"},
    {"name" => "The Reader", "age" => "Unknowable", "gender" => "Unknowable"},
);
```

Seperti yang kita lihat dari contoh ini, daftar bisa berisi lebih dari sekadar angka dan string: kita bisa menggunakan hash juga!

Daftar hash yang berisi informasi kerumunan ini kebal terhadap masalah yang kita lihat di awal bab ini. Tidak masalah dalam urutan kombinasi kunci-nilai dari umur, nama, atau gender; hash akan tetap mengandung informasi yang benar di tempat yang tepat. Sebagai tambahan, kita bisa merujuk ke nilai-nilai ini dengan kuncinya, alih-alih harus mengingat posisi mereka.

##### Jenis Kunci Lain

Sebelum kita melanjutkan, saya ingin kita berfokus sedikit lebih lama pada hash. So far, we've seen that hashes are made up of a series of keys and values. Those keys in our hashes have only been strings, but the values have been a mixture of strings (for name and gender) and numbers (for age). 

Dalam Perl, kunci dan nilai bisa berupa apa saja. Kunci bisa berupa angka, string, daftar, dan banyak lagi. Mari kita ambil contoh di mana kita meminta sepuluh orang untuk memilih angka dalam rentang 1 sampai 5. Kita bisa menggunakan kunci angka untuk mewakili angka yang dipilih orang-orang tersebut:

```perl linenums="1"
my %choices = (
    1 => 4,
    2 => 1,
    3 => 2,
    4 => 2,
    5 => 1,
);
```

Kemudian kita bisa dengan mudah mengetahui berapa banyak orang yang memilih angka 1 atau 2 dengan menggunakan kunci tersebut:

```perl linenums="1"
$choices{1}; # 4
$choices{2}; # 1
```

Kita dapat dengan jelas menggunakan angka sebagai kunci dan nilai dalam hash dan Perl tidak masalah dengan itu. Sekarang kita telah menetapkan hal itu, saya ingin memperkenalkan Anda pada satu jenis data lain dalam Perl dengan sedikit contoh kode.

Salah satu kejadian umum dalam kode Perl yang mungkin Anda lihat adalah hash yang terlihat seperti ini:

```perl linenums="1"
my %person = (
    name => "Izzy",
    age => "30ish",
    gender => "Female"
);
```

Ini adalah cara penulisan singkat dari:

```perl linenums="1"
my %person = (
    "name" => "Izzy",
    "age" => "30ish",
    "gender" => "Female"
);
```

Kunci dalam kedua contoh ini bukanlah angka, string, daftar, atau hash. Tapi mereka terlihat seperti string, bukan? Jadi apa mereka? Kunci-kunci ini disebut atom. Mereka adalah jenis data dalam Perl yang umumnya digunakan untuk mewakili nama sesuatu, seperti dalam kasus ini. 

Seperti yang telah kita lakukan sebelumnya, kita bisa mengakses nilai yang terkait dengan kunci atom dengan menggunakan cara yang sama:

```perl linenums="1"
$person{name}; # "Izzy"
```

Ini sedikit lebih singkat dibandingkan `$person{"name"}` dan cara kita mendefinisikan hash juga sedikit lebih singkat, sehingga umumnya lebih disukai menggunakan atom dibandingkan string sebagai kunci dalam hash. 

Dengan demikian, mulai sekarang kita akan lebih sering menggunakan atom untuk kunci dalam hash karena itu lebih sedikit pengetikan dan membuat kode kita sedikit lebih rapi.

Dan sekarang untuk kembali mengumpulkan informasi tentang siapa yang berkumpul di sini hari ini. Untuk ini, kita bisa menggunakan daftar hash dan membuat kunci-kunci tersebut sebagai atom, dan nilainya sebagai string:

```perl linenums="1"
my @those_who_are_assembled = (
    {name => "Izzy", age => "30ish", gender => "Female"},
    {name => "The Author", gender => "Male", age => "30ish"},
    {name => "The Reader", gender => "Unknowable", age => "Unknowable"},
);
```

Izzy dengan semangat menghilang ke kerumunan lagi dengan pengetahuan baru tentang hash ini dan mulai mengumpulkan informasi orang-orang.

--- 

#### 5. Funky functions
Setelah sekitar setengah jam, Izzy muncul kembali dari entah di mana. Layar komputernya bersinar dengan informasi yang telah dia kumpulkan dari banyak orang. Kami tidak yakin sudah berapa lama dia kembali, tetapi begitu perhatian kami tertuju padanya, dia mulai berbicara: "Oke, jadi kamu bisa merepresentasikan berbagai jenis hal di Perl — string, angka, daftar, hash — tetapi apa sebenarnya gunanya melakukan semua itu? Apa yang bisa kamu lakukan dengan mereka? Apakah saya harus selalu menulis kode untuk bekerja dengan berbagai jenis data ini sepanjang waktu? Apakah komputer bisa mengingat kode juga?"

Yah, Izzy, itu adalah pertanyaan yang sangat cerdas dan kebetulan mengarah ke bagian berikutnya dari site ini. Terima kasih untuk itu.

Ya, kamu bisa menyuruh komputer mengingat beberapa kode juga. Ini akan menghemat banyak pengetikan. Banyak sekali. Kamu akan mendapatkan kembali waktu hidupmu bertahun-tahun!

Oke, cukup basa-basinya. Mari kita lihat salah satu cara kita dapat menggunakan komputer untuk mengingat kode:

```perl linenums="1"
my $greeting = sub {
    my $place = shift;
    return "Hello, $place!";
};
```

Ini disebut fungsi (function), dan kita bisa menulis kode apapun yang ingin kita perintahkan kepada komputer untuk diingat dan digunakan nanti, sama seperti kita bisa menyuruh komputer untuk mengingat string, angka, daftar, atau hash. Kode Perl sangat bergantung pada fungsi, dan sekarang kita memahami mengapa ini disebut bahasa "fungsional." Itu berarti bahasa ini menggunakan fungsi untuk menyelesaikan pekerjaan. Mulai sekarang, kamu akan melihat banyak fungsi dalam kode Perl.

Kata `sub` menunjukkan kepada komputer bahwa kita akan mendefinisikan sebuah fungsi — karena mengetik "function" setiap kali terlalu lama — dan definisi fungsi ini tidak berhenti sampai kita mencapai akhirnya.

Bagian `(place)` mendefinisikan sebuah argumen untuk fungsi; anggap saja seperti variabel yang hanya tersedia dalam fungsi tersebut. Tanda panah `->` memberi tahu komputer bahwa kita telah selesai mendefinisikan argumen untuk fungsi, dan apa pun setelah ini adalah kode yang akan dijalankan.

**Contoh Definisi Fungsi**
Bagian 5.1: Contoh definisi fungsi

Setelah kita menekan enter di akhir baris ini, komputer akan memberikan output yang menunjukkan bahwa ia telah menerima fungsi kita. Meskipun outputnya mungkin tidak terlalu ramah, setidaknya itu adalah sesuatu yang memberitahu kita bahwa komputer telah melakukan sesuatu.

```perl linenums="1"
my $greeting = sub {
    my $place = shift;
    return "Hello, $place!";
};
```

Kita telah menetapkan fungsi kita ke variabel `$greeting`, jadi itulah yang akan diingat oleh komputer sebagai fungsi tersebut. "Bagaimana kita menggunakan fungsi ini?", Izzy bertanya dengan penuh semangat, terkesan dengan kemampuan komputer untuk mengingat fungsi. Saya yakin kamu juga bertanya-tanya hal yang sama, pembaca terhormat.

Nah Izzy (dan pembaca terhormat), kita perlu menggunakan beberapa kode baru yang belum kita lihat sebelumnya:

```perl linenums="1"
print $greeting->("World");
```

Inilah cara kita menjalankan fungsi tersebut. Kita menjalankan fungsi ini dengan menambahkan tanda panah `->` setelah namanya. Tanda kurung setelah tanda panah tersebut mewakili argumen untuk fungsi. Kali ini, `place` akan menjadi "World". Namun, ini tidak selalu harus "World". Ini bisa menjadi apa saja yang kamu inginkan:

```perl linenums="1"
print $greeting->("Mars");
print $greeting->("Narnia");
print $greeting->("Tanah Air");
```

Setiap kali kita menjalankan fungsi, kita memberikan nilai baru untuk `place`. Kita tidak perlu menetapkan `place` sendiri, karena fungsi akan menangani itu. Tapi bagaimana dengan variabel `place` dari kode sebelumnya? Apakah itu berubah?

```perl linenums="1"
print $place; # Variabel ini tidak tersedia di luar fungsi
```

Komputer tahu bahwa `place` dari luar fungsi berbeda dengan `place` di dalam fungsi, jadi komputer menjaga keduanya tetap terpisah. Komputer cukup pintar untuk mengetahui bahwa `place` di luar mungkin tidak ada, jadi dia tidak bergantung padanya.

Fungsi kita sejauh ini hanya mengambil string dan memasukkannya ke dalam string lain, tetapi fungsi dapat menjalankan kode apapun. Mari kita lihat contoh fungsi lain yang menggunakan angka. Fungsi ini akan mengonversi suhu dalam celsius menjadi fahrenheit:

```perl linenums="1"
my $c_to_f = sub {
    my $c = shift;
    return $c * 1.8 + 32;
};
```

Rumus matematis untuk mengonversi celsius ke fahrenheit adalah mengalikan dengan 1.8 dan kemudian menambahkan 32, yang persis kita lakukan dalam fungsi kita.

Mari kita jalankan fungsi kita dengan beberapa suhu celsius:

```perl linenums="1"
print $c_to_f->(20);  # 68.0
print $c_to_f->(24);  # 75.2
print $c_to_f->(40);  # 104.0
```

Jika kamu ingin memeriksa hasilnya, cari di Google dengan pencarian seperti "20 celsius in fahrenheit" dan Google akan mengonfirmasi jawabannya.

##### Fungsi dengan Banyak Argumen
Hal lain yang berguna tentang fungsi adalah bahwa fungsi tidak terbatas pada satu argumen saja. Kamu dapat mendefinisikan sebuah fungsi yang menerima sebanyak mungkin argumen yang kamu inginkan:

```perl linenums="1"
my $greeting = sub {
    my ($name, $gender, $age) = @_;
    return "Hello, $name! Saya melihat kamu $gender dan berusia $age tahun.";
};
```

Fungsi ini memiliki 3 argumen, dan ketika kita menjalankannya, kita harus memberikan ketiga argumen tersebut. Untuk melakukannya, kita hanya memisahkannya dengan koma, seperti kita memisahkan item dalam daftar sebelumnya, hanya saja tanpa tanda kurung siku ([]) di sekitar argumen.

```perl linenums="1"
print $greeting->("Izzy", "Perempuan", "30-an");
```

Kita bisa menggunakan sebanyak mungkin argumen yang kita inginkan dalam fungsi, tetapi kita perlu berhati-hati ketika menjalankan fungsi. Jika kita memberikan jumlah argumen yang salah, Perl akan memberikan error yang menegur kita.

```perl linenums="1"
print $greeting->("Izzy"); 
# Ini akan menghasilkan error karena jumlah argumen tidak sesuai
```

##### Operator Capture di Perl
Di Perl, kita bisa menggunakan cara yang lebih ringkas untuk mendefinisikan fungsi. Salah satunya adalah dengan menggunakan "anonymous subroutine" yang menangkap argumen secara otomatis dengan `@_`, tetapi cara ini sudah diwakili oleh contoh-contoh sebelumnya, sehingga kita tidak perlu mengubah formatnya.

##### Menyimpan Kode untuk Digunakan Nanti
Meskipun sangat berguna untuk menjalankan kode melalui prompt **re.pl**, mungkin kamu ingin menyimpan kode tertentu untuk dijalankan nanti. Mungkin pada titik ini kamu memiliki ide yang ingin dicoba dan ingin menyimpannya di tempat lain, karena prompt **re.pl** hanya akan mengingat apa yang kamu ketik selama sesi aktif. Setelah ditutup, kode itu hilang dan kamu harus mengetikkannya kembali.

Untuk menyimpan kode Perl kamu, kamu bisa membuat file baru di editor teks favoritmu, masukkan kode yang diinginkan, dan simpan dengan nama seperti `hello.pl`. Ekstensi `.pl` menunjukkan bahwa file ini adalah skrip Perl.

Untuk menjalankan kode di dalam file tersebut, cukup jalankan:

```
perl hello.pl
```

Tidak perlu prompt lagi!

##### Latihan
1. Buat fungsi yang mengubah suhu Fahrenheit ke Celsius.
2. Buat fungsi yang mengembalikan jumlah detik dalam jumlah hari tertentu. Misalnya, `seconds(2)` seharusnya memberi tahu berapa banyak detik dalam 2 hari.
3. Buat fungsi yang mengambil dua hash dengan kunci "umur" dan mengembalikan rata-rata umur.
4. Simpan salah satu dari tiga solusi ini dalam file sendiri dan jalankan melalui **perl**.

---

#### 6. Pattern Matching

Kembali ke Bab 2, Anda telah melihat bahwa tanda sama dengan (=) membuat komputer mengingat sesuatu.

```perl linenums="1"
my $kalimat = "Kalimat yang sangat panjang dan rumit ⏎
yang lebih baik tidak kita ulangi.";

print $kalimat;
```
outputnya:
```
Kalimat yang sangat panjang dan rumit ⏎
yang lebih baik tidak kita ulangi.
```

```perl linenums="1"
my $nilai = 2 / 5 * 100;
print $nilai;
```
outputnya:
```
40
```

Meskipun kode ini benar, tanda sama dengan (=) lebih dari sekadar menetapkan satu nilai pada satu waktu. Ada fitur tersembunyi dari Perl yang belum kita tunjukkan, dan fitur itu adalah *pattern matching*. Anda akan sering menggunakan fitur ini ketika memprogram dengan Perl — sebanyak fungsi-fungsi lainnya! Mari kita bahas lebih dalam di sini.

##### Sama dengan Bukan Hanya untuk Persamaan

Tanda sama dengan tidak hanya digunakan untuk menetapkan nilai, tetapi juga untuk mencocokkan sesuatu. Anda bisa menganggapnya seperti tanda sama dengan dalam matematika, di mana sisi kiri harus sama (atau "cocok") dengan sisi kanan agar persamaan itu valid.

Misalnya, jika kita mencoba membuat `2 + 2 = 5`, seperti yang dikatakan Partai dalam novel *Nineteen Eighty-Four* karya George Orwell, Perl tidak akan menerimanya.

```perl linenums="1"
my $hasil = 5 == 2 + 2;
print $hasil;
```
outputnya:
```
0
```

Di sini, Perl memberi tahu kita bahwa `2 + 2` memang bukan 5. Dalam Perl, sisi kiri harus mengevaluasi hasil yang sama dengan sisi kanan. Ini akan membuat komputer senang:

```perl linenums="1"
my $hasil = 4 == 2 + 2;
print $hasil;
```
outputnya:
```
1
```

Demikian pula, jika kita memiliki dua string yang identik di kedua sisi tanda sama dengan, ini juga akan membuat komputer senang:

```perl linenums="1"
my $hasil = "anjing" eq "anjing";
print $hasil;
```
outputnya:
```
1
```

Mari kita coba sesuatu yang lebih kompleks, seperti mencocokkan pola pada daftar (*list*).

##### Pattern Matching dengan List

Katakanlah kita memiliki daftar semua orang yang berkumpul di sini:

```perl linenums="1"
my @yang_berkumpul = (
    { umur => "30-an", gender => "Perempuan", nama => "Izzy" },
    { umur => "30-an", gender => "Laki-laki", nama => "Penulis" },
    { umur => "56", gender => "Laki-laki", nama => "Roberto" },
    { umur => "38", gender => "Perempuan", nama => "Juliet" },
    { umur => "21", gender => "Perempuan", nama => "Mary" },
    { umur => "67", gender => "Perempuan", nama => "Bobalina" },
    { umur => "54", gender => "Laki-laki", nama => "Charlie" },
    { umur => "10", gender => "Laki-laki", nama => "Charlie (tidak ada hubungan)" }
);
```

Sekarang, katakanlah kita ingin mengambil 3 orang pertama dalam daftar ini, lalu mengabaikan sisanya. Kita bisa menggunakan *pattern matching* di daftar ini:

```perl linenums="1"
my ($pertama, $kedua, $ketiga, @lainnya) = @yang_berkumpul[0..2], @yang_berkumpul[3..$#yang_berkumpul];
```

Dengan kode ini, kita memberitahu Perl untuk menetapkan item pertama, kedua, dan ketiga dari daftar ke variabel `pertama`, `kedua`, dan `ketiga`. Kita juga meminta sisa daftar ditempatkan di variabel `lainnya`.

Kita dapat memeriksa nilai dari setiap variabel:

```perl linenums="1"
print $pertama->{nama};
print $kedua->{nama};
print $ketiga->{nama};
```
outputnya:
```bash
Izzy
Penulis
Roberto
```

Jika Anda ingin mengambil lebih banyak data atau sisa daftar, prosesnya serupa. Anda juga bisa menggunakan teknik ini pada maps.

##### Pattern Matching dengan Hash (Map)

Mari kita katakan bahwa kita memiliki sebuah hash berisi informasi tentang seseorang:

```perl linenums="1"
my %orang = (nama => "Izzy", umur => "30-an");
```

Jika Anda ingin menarik kedua nilai sekaligus menggunakan *pattern matching*, kita bisa menulis seperti ini:

```perl linenums="1"
my ($nama, $umur) = @orang{'nama', 'umur'};
print $nama;
print $umur;
```
outputnya:
```bash
Izzy
30-an
```

##### Pattern Matching di dalam Fungsi

Kita juga bisa menggunakan *pattern matching* di dalam fungsi untuk membuatnya merespons secara berbeda berdasarkan argumen yang diterima.

```perl linenums="1"
sub jalan {
    my ($tipe) = @_;
    if ($tipe eq "tinggi") {
        return "Kamu mengambil jalan tinggi!";
    } elsif ($tipe eq "rendah") {
        return "Aku akan mengambil jalan rendah!";
    } else {
        return "Ambil 'jalan tinggi' atau 'jalan rendah', terima kasih!";
    }
}

print jalan("tinggi");
print jalan("rendah");
print jalan("tengah");
```
outputnya:
```bash
Kamu mengambil jalan tinggi!
Aku akan mengambil jalan rendah!
Ambil 'jalan tinggi' atau 'jalan rendah', terima kasih!
```

##### Latihan

Buatlah sebuah fungsi yang menerima map yang berisi "nama" dan "umur", atau hanya map dengan "nama". Ubah output tergantung pada apakah "umur" ada atau tidak.

---

Berikut adalah versi yang telah disesuaikan dengan instruksi Anda untuk mengganti Elixir dengan Perl, serta penyesuaian kode dan penjelasan sesuai praktik terbaik Perl.

---

#### 7. Bagian 2: Rekap

Perl akan cukup sulit jika Anda harus menulis semua kode program sendiri. Kita telah melihat bahwa jika Anda ingin menambah, mengurangi, mengalikan, atau membagi angka, Perl siap membantu Anda:

```perl linenums="1"
print 2 + 4, "\n";  # 6
print 3 - 6, "\n";  # -3
print 4 * 12345, "\n";  # 49380
print 1234 / 4, "\n";  # 308.5
```

Kita juga melihat bahwa Perl bisa menjalankan kode di dalam kode lain, melalui interpolasi string:

```perl linenums="1"
my $place = "World";
print "Hello $place!\n";  # "Hello, World!"
```

Kita juga melihat bahwa Perl dapat menangani daftar (array):

```perl linenums="1"
my @list = ("chicken", "beef", "and so on");
print "@list\n";  # "chicken beef and so on"
```

Dan juga bisa menangani hash (map):

```perl linenums="1"
my %person = (name => "Izzy", age => "30ish", gender => "Female");
print $person{name}, "\n";  # "Izzy"
```

Kita juga melihat bahwa Perl dapat mengingat fungsi untuk kita:

```perl linenums="1"
my $greeting = sub {
    my $name = shift;
    return "Hello, $name!";
};
print $greeting->("Izzy"), "\n";  # "Hello, Izzy!"
```

Dan di bab sebelumnya, kita melihat bahwa kita bisa melakukan *pattern matching* (cocok pola):

```perl linenums="1"
my %person = (name => "Izzy", age => "30ish");
my $name = $person{name};
my $age = $person{age};
print "$name\n";  # "Izzy"
print "$age\n";  # "30ish"
```

Tapi bagaimana jika saya mengatakan bahwa Perl bisa melakukan lebih dari sekadar operasi matematika sederhana, interpolasi string, mengingat fungsi, dan cocok pola? Bagaimana jika saya mengatakan bahwa Perl sudah menyediakan beberapa fungsi yang menggunakan semua hal di atas untuk membantu Anda membangun program, hanya jika Anda memintanya?

Yah, yang perlu Anda lakukan hanyalah memintanya dan Perl akan memberikan.

---

## Bagian Tiga: Building on the foundations
Berikut adalah versi yang telah diubah sesuai dengan instruksi Anda, mengubah Elixir menjadi Perl, serta menyesuaikan kode dan penjelasan sesuai dengan praktik terbaik Perl:

---

#### 8. Bekerja dengan String, Input, dan Output

Di bab ini, kita akan membahas beberapa fungsi bawaan yang dimiliki Perl. Kita akan fokus secara khusus pada string, input, dan output. Perl memiliki beberapa fungsi yang sangat berguna dan kami akan melihat beberapa contohnya di sini.

##### Bekerja dengan String

Kita akan mulai dengan melihat fungsi untuk bekerja dengan string. String adalah tempat kita memulai di Bab 1, jadi masuk akal jika kita mulai dari sini juga.

###### Membalikkan String
Pernahkah Anda ingin membalikkan sebuah kalimat, tetapi tidak ingin mengetik semua karakter satu per satu? Perl memiliki fungsi yang berguna untuk ini, yaitu `reverse`. Berikut contoh penggunaannya:

```perl linenums="1"
print reverse("balikkan ini"), "\n";
```

Hasilnya:
```
"ini nakklab"
```

##### Tanpa Kurung!
Saat kita memanggil fungsi di Perl, kita biasanya menyertakan argumen di dalam kurung. Kita melakukan ini untuk membuatnya lebih jelas. Namun, Perl cukup pintar untuk memahami argumen yang kita berikan meski tanpa kurung.

```perl linenums="1"
print reverse "balikkan ini", "\n";
```

Secara umum, praktik terbaiknya adalah selalu menggunakan kurung.

Izzy pun berkomentar, "Wooooow, keren banget!" Lalu dia bertanya, "Apa lagi yang dimiliki Perl?" Kita akan sampai ke sana, Izzy. Mari kita pahami dulu apa yang terjadi di sini.

Fungsi-fungsi yang disediakan Perl dipisahkan ke dalam sesuatu yang mirip dengan laci peralatan dapur, disebut modul. Misalnya, di dapur Anda, mungkin ada laci dengan garpu, pisau, dan sendok; di laci lain mungkin ada gelas ukur, dan di laci lain ada lap tangan. Di Perl, fungsi-fungsi untuk bekerja dengan berbagai jenis data dipisahkan ke dalam modul-modul yang berbeda. Ini membuat mencari fungsi untuk bekerja dengan jenis data tertentu menjadi mudah.

Di sini, kita menggunakan fungsi `reverse` dari Perl untuk membalikkan string "balikkan ini", yang menghasilkan string terbalik: "ini nakklab".

##### Memisahkan String
Bagaimana jika kita ingin memisahkan string menjadi kata-kata individual? Untuk itu, kita bisa menggunakan fungsi `split`:

```perl linenums="1"
my @words = split(/\s+/, "pisahkan string saya menjadi beberapa bagian");
print "@words\n";
```

Hasilnya:
```
"pisahkan string saya menjadi beberapa bagian"
```

Kita sekarang memiliki daftar kata-kata dari string. Kita akan melihat apa yang bisa dilakukan dengan daftar seperti ini di bab selanjutnya. Untuk saat ini, mari kita lihat fungsi lain di modul string.

##### Mengganti Bagian dari String
Bagaimana jika kita ingin mengganti semua kemunculan karakter tertentu dalam string dengan karakter lain? Perl memiliki fungsi `s///` untuk ini:

```perl linenums="1"
my $string = "moo";
$string =~ s/o/e/g;
print "$string\n";  # "mee"
```

Fungsi ini menggantikan semua "o" dalam string dengan "e".

##### Mengubah Semua Huruf Menjadi Huruf Besar
Bagaimana jika kita ingin membuat komputer mengubah string menjadi versi "berteriak"? Kita bisa menggunakan `uc` untuk ini:

```perl linenums="1"
print uc("tidak terlalu tenang lagi"), "\n";  # "TIDAK TERLALU TENANG LAGI"
```

##### Mengubah Semua Huruf Menjadi Huruf Kecil
Sebaliknya, ada `lc` untuk membuat semua huruf menjadi huruf kecil:

```perl linenums="1"
print lc("TERLALU KERAS"), "\n";  # "terlalu keras"
```

Seperti yang Anda lihat, Perl memiliki fungsi yang membantu kita untuk memecah string, mengubah huruf menjadi huruf besar/kecil. Ada banyak fungsi lain yang bisa digunakan untuk bekerja dengan string, dan kita akan melihat beberapa di antaranya di waktu mendatang.

##### Input dan Output

Input dan output adalah dua hal mendasar yang Anda kerjakan saat pemrograman. Pemrograman adalah tentang mengambil beberapa data sebagai input dan mengubahnya menjadi bentuk output. Kita telah melihat ini beberapa kali dengan fungsi yang telah kita definisikan dan gunakan di sepanjang bacaan ini.

##### Membuat Prompt Sendiri
Mari kita buat program yang meminta nama pengguna dan menggunakan input tersebut untuk menampilkan pesan.

```perl linenums="1"
print "Apa nama Anda? ";
my $name = <STDIN>;
chomp $name;

print "Berapa umur Anda? ";
my $age = <STDIN>;
chomp $age;

print "Halo, $name! Anda berusia $age tahun? Wah, sudah cukup tua!\n";
```

Di sini, kita menggunakan fungsi `chomp` untuk menghapus karakter baris baru dari input, yang dihasilkan saat pengguna menekan enter.

#### Dunia yang Tidak Berubah (Immutability)

Saat bekerja dengan string atau data lainnya di Perl, penting untuk memahami bahwa data yang dimodifikasi sebenarnya tidak mengubah data aslinya kecuali kita menugaskan ulang variabel tersebut. Mari kita lihat contohnya:

```perl linenums="1"
my $kalimat = "kalimat biasa";
my $upper_case = uc($kalimat);

print "$kalimat\n";  # "kalimat biasa"
print "$upper_case\n";  # "KALIMAT BIASA"
```

Dengan memanggil `uc`, kita tidak mengubah variabel `$kalimat`. Data di dalam variabel tersebut tetap tidak berubah. Jika ingin mengubah nilai variabel, kita perlu menetapkannya kembali.

---

#### 9. Bekerja dengan list

Pada bab ini, kita akan membahas beberapa fungsi yang dengan baik hati telah disediakan oleh Perl untuk membantu kita bekerja dengan daftar (lists).

Sama seperti ada modul `String` untuk bekerja dengan string, ada juga modul `List` untuk bekerja dengan daftar. Modul ini mencakup fungsi seperti `first` yang akan memberi tahu Anda apa item pertama dalam daftar:

```perl linenums="1"
use List::Util 'first';
my @list = (1, 2, 3, 4);
print first { 1 } @list; 
```

Dan itu juga memungkinkan Anda untuk mengetahui apa item terakhirnya juga:

```perl linenums="1"
my @list = (1, 2, 3, 4);
print $list[-1];
```

Kita sudah melihat sebelumnya bagaimana cara membalikkan string, tetapi bagaimana jika kita ingin membalikkan sesuatu yang lain, seperti daftar ini?

```perl linenums="1"
my @animals_or_derivatives_of_animals = ("cat", "dog", "cow", "turducken");
```

Kita mungkin berpikir bahwa sama seperti `first` dan `last`, seharusnya ada juga `reverse`! Kita mungkin berpikir demikian karena Perl menyediakan cara untuk membalikkan string—dengan `reverse("string")`—jadi mengapa tidak untuk daftar juga? Mari kita coba:

```perl linenums="1"
my @reversed_list = reverse @animals_or_derivatives_of_animals;
print @reversed_list;
```

Perl memberi kita kemampuan untuk membalikkan daftar, berbeda dengan yang kita temui sebelumnya. Namun, kita akan menyelidiki lebih lanjut bagaimana fungsi ini bekerja dan apa yang membuatnya berguna.

Izzy bertanya: "Hei, apa arti /1 setelah nama fungsi?"
Senang Anda bertanya! Ini menunjukkan **arity** dari fungsi tersebut. Arity adalah istilah yang digunakan untuk menunjukkan jumlah argumen.

Fungsi dalam Perl juga bisa berbeda berdasarkan jumlah argumen yang diterima. Misalnya, kita bisa memiliki fungsi yang menerima satu atau dua argumen, dan itu akan mengubah bagaimana fungsinya bekerja.

Contoh bagus dari ini adalah fungsi `split` yang kita lihat sebelumnya. Fungsi ini memiliki dua varian, satu yang menerima satu argumen (`split/1`) dan satu lagi yang menerima dua argumen (`split/2`). Kita hanya melihat versi satu argumen sebelumnya:

```perl linenums="1"
my @words = split(" ", "Hello, World!");
print "@words";  # Output: Hello, World!
```

Namun, jika kita memberikan argumen kedua pada fungsi ini, perilakunya akan berbeda:

```perl linenums="1"
my @words = split("o", "Hello, World!");
print "@words";  # Output: Hell , W rld!
```

Nama fungsi tidak berubah, tetapi jumlah argumen berubah, dan itu mempengaruhi bagaimana fungsi tersebut berperilaku.

Argumen kedua untuk `split/2` memberi tahu komputer di mana memisahkan string. Dengan versi satu argumen, komputer berasumsi kita ingin memisahkan berdasarkan spasi di antara kata-kata. Dengan versi dua argumen — yaitu versi `/2` — kita memberi tahu bahwa kita ingin memisahkan pada karakter "o".

Pada titik ini, juga perlu disebutkan bahwa fungsi `uc` yang kita gunakan sebelumnya juga memiliki arity `uc/1`. Sama seperti `/2` menunjukkan bahwa fungsi menerima dua argumen, `/1` menunjukkan bahwa fungsi ini menerima satu argumen. Ketika merujuk ke fungsi Perl, pastikan untuk menyertakan arity serta nama fungsinya.

Ini adalah perbedaan penting yang harus dibuat dalam Perl, dan oleh karena itu saya akan mengulanginya lagi:

Fungsi tidak hanya berbeda berdasarkan nama, tetapi juga berdasarkan jumlah argumen yang mereka terima.

Ok, jadi kita sudah membahas apa arti /1, sekarang mari kita bicarakan mengapa `reverse/1` di Perl ada dan bagaimana fungsinya.

Terima kasih Pembaca, tapi fungsi putri kita ada di modul kastil lain.

Versi singkat mengapa fungsi `List.reverse/1` tidak ada adalah karena fungsi tersebut berada di modul yang terpisah; fungsi ini ada di modul `Enum`. Nama `Enum` adalah singkatan dari **Enumerable**, dan penulis bacaan ini juga merasa kesulitan mengetikkan `Enumerable` dengan benar setiap saat. Untungnya ada autocomplete.

"Apa sebenarnya enumerable itu?", teriak Izzy. Sabar dulu, Izzy. Kita akan sampai ke sana.

Daftar adalah salah satu jenis data di Perl yang disebut enumerable. Hash (atau map) juga enumerable. Artinya, mereka dapat dihitung satu per satu; yang berarti kita bisa melakukan sesuatu pada setiap item di dalam objek enumerable (seperti daftar atau hash). Misalnya, jika kita menulis daftar kita di selembar kertas, itu mungkin akan terlihat seperti ini:

```
Kucing
Anjing
Sapi
Turducken
```

Adalah mungkin untuk menulis setiap item dari daftar secara terpisah dari item lainnya di dalam daftar. Karena kita bisa melakukan ini, kita bisa dengan aman mengatakan bahwa daftar ini enumerable. Kita mungkin bisa mencoba melakukan hal yang sama untuk sebuah angka (misalnya 1.354), tapi tidak akan masuk akal:

```
1
3
5
4
```

Angka tidak enumerable karena tidak masuk akal jika ditulis seperti itu, tidak seperti daftar.

Mirip dengan ini, kita bisa mengiterasi melalui hash. Jika kita mengambil salah satu hash dari contoh sebelumnya:

```perl linenums="1"
my %info = (nama => "Izzy", umur => "30an", gender => "Perempuan");
```

dan menulis setiap pasangan kunci dan nilai, itu akan terlihat seperti ini:

```
Nama
Izzy
Umur
30an
Gender
Perempuan
```

Lagi-lagi, masuk akal jika hash dianggap enumerable karena kita dapat menghitung setiap pasangan kunci dan nilai di dalamnya.

##### Sekarang saatnya pengungkapan besar
Kita perlu ingat bahwa ketika bekerja dengan data enumerable di Perl, fungsi yang kita butuhkan mungkin berada di modul lain. Meskipun pasti ada modul List dan Hash, kita juga perlu melihat ke dalam modul `List::Util` atau `List::MoreUtils` untuk fungsi yang kita inginkan.

Tadi kita mencoba mencari di modul `List` untuk menemukan fungsi `reverse/1` agar bisa membalik daftar kita, tapi tidak ada di sana. Setelah beberapa waktu, kita mengetahui bahwa fungsi ini sebenarnya berada di modul `List::Util`, jadi mari kita coba menggunakan fungsi tersebut. Sebelum itu, mari kita lihat kembali daftar kita dalam bentuk Perl:

```perl linenums="1"
my @animals_or_derivatives_of_animals = ("cat", "dog", "cow", "turducken");
```

Karena sekarang kita tahu bahwa daftar adalah enumerable, dan bahwa fungsi `List.reverse/1` tidak ada tetapi kita juga (sekarang) tahu bahwa ada modul `List::Util` untuk bekerja dengan hal-hal semacam ini, kita bisa menebak bahwa ada fungsi `reverse`. Mari kita coba lihat:

```perl linenums="1"
use List::Util qw(reverse);
my @reversed_animals = reverse @animals_or_derivatives_of_animals;
print "@reversed_animals";
```

**Hore!** Kita berhasil membalik daftar kita.

Fitur wajah Izzy kembali rileks setelah konsentrasi yang intens dan dia bertanya, "Hei, tadi kamu sebutkan kita bisa menghitung melalui daftar atau hash, tapi kamu tidak memberikan contohnya. Apa maksudnya?" Anda benar sekali, Izzy. Saya terlalu teralihkan dengan menjelaskan mengapa `List.reverse/1` tidak ada sehingga lupa menjelaskan cara menghitung item di enumerable. Saya senang ada yang memperhatikan.

##### Mengiterasi melalui enumerables
Untuk menyenangkan Izzy (dan massa yang dia pimpin) sekali lagi, kita akan melihat bagaimana cara mengiterasi melalui enumerables. Artinya, kita akan mengambil enumerable (seperti daftar atau hash) dan melewati setiap item di dalamnya, lalu melakukan sesuatu pada setiap item tersebut.

Mari kita mulai dengan daftar. Bagaimana kalau daftar lima kota paling layak huni di dunia, untuk variasi?

```perl linenums="1"
my @cities = ("vienna", "melbourne", "osaka", "calgary", "sydney");
```

Cara paling sederhana untuk mengiterasi melalui daftar di Perl adalah menggunakan fungsi `foreach`. Mari kita lihat contohnya:

```perl linenums="1"
foreach my $city (@cities) {
    print "$city\n";
}
```

Output:

```
vienna
melbourne
osaka
calgary
sydney
```

Contoh ini mencetak setiap kota dalam daftar pada baris baru. Ini sangat mirip dengan bagaimana kita mengiterasi melalui daftar di bahasa lain.

##### Mengubah nilai dengan fungsi `map`
Jika kita ingin mengubah daftar ini menjadi daftar dengan nama kota yang dikapitalisasi, kita bisa menggunakan fungsi `map`:

```perl linenums="1"
my @capitalized_cities = map { ucfirst($_) } @cities;
print "@capitalized_cities\n";
```

Output:

```
Vienna Melbourne Osaka Calgary Sydney
```

Fungsi `map` menerima blok kode sebagai argumen, dan menerapkannya ke setiap item dalam daftar. Dalam contoh ini, kita menggunakan `ucfirst` untuk mengkapitalisasi huruf pertama dari setiap kota.

Demikianlah cara kita mengiterasi dan memanipulasi enumerables di Perl.

##### Mengapa disebut "map"?

Sejujurnya, saya tidak terlalu memikirkan nama "map" sebelum saya menulis bagian ini dalam bacaan ini. Saya selalu mengenalnya sebagai "map", tetapi tidak pernah benar-benar bertanya mengapa. Saya ingin menjawabnya di sini, tetapi saya sendiri tidak tahu, jadi saya bertanya di Twitter mengapa disebut "map".

Konsensus dari komunitas Twitter tampaknya adalah bahwa ini adalah istilah yang berasal dari matematika, yang maknanya berasal dari peta kartografer — di mana dimensi bumi diwakili secara grafis pada peta. Ketika Anda memperbesar atau memperkecil satu bagian dari peta, Anda harus melakukan transformasi yang sama pada bagian lainnya, jika tidak, peta itu tidak lagi masuk akal. Saya merasa hal ini cukup menarik, jujur saja.

Dalam matematika, istilah "map" berarti mengambil satu set angka, lalu menerapkan fungsi yang sama di seluruh elemen tersebut untuk mengubahnya menjadi set angka yang baru. Hei, itu mirip dengan apa yang kita lakukan di sini — hanya saja kita menggunakan kata-kata, bukan angka. Kita mengambil daftar string, lalu mengubahnya menjadi daftar string yang baru.

##### Buat Fungsi Sendiri

Contoh cepat lainnya. Saat menggunakan `foreach` atau `map` di Perl, kita tidak harus menggunakan fungsi bawaan sebagai argumen kedua. Kita bisa membuat fungsi kita sendiri. Misalnya, kita memiliki daftar angka seperti ini:

```perl linenums="1"
my @numbers = (4, 8, 15, 16, 23, 42);
```

Dan kita ingin mengalikan setiap angka dengan 2. Karena kita malas dan ingin komputer melakukan pekerjaan berat, kita bisa menggunakan fungsi `map` untuk mencapai tujuan ini:

```perl linenums="1"
my @result = map { $_ * 2 } @numbers;
print "@result\n";  # Output: 8 16 30 32 46 84
```

Dengan fungsi kita sendiri, kita mengambil setiap elemen dari daftar — yang diwakili sebagai variabel `$_` — dan mengalikannya dengan 2. Ketika fungsi `map` selesai, ia menghasilkan daftar baru yang menampilkan hasil dari penerapan fungsi tersebut pada semua elemen daftar.

##### Mereduksi Sebuah Enumerable

Sekarang kita telah melihat bagaimana menggunakan dua fungsi di Perl: `foreach` dan `map`. Ini adalah dua fungsi yang paling sering digunakan, itulah mengapa kita membahasnya. Tetapi ada satu fungsi lain yang ingin saya sampaikan juga: `reduce`. Ini adalah fungsi yang sangat berguna!

`reduce` memungkinkan kita untuk melakukan iterasi melalui sebuah daftar dan secara bertahap menerapkan fungsi ke setiap elemen dalam daftar tersebut untuk mendapatkan satu nilai akhir. Pikirkan seperti saat Anda memasak: Anda mengurangi semua bahan menjadi satu hidangan. Anda tidak berpikir tentang spaghetti bolognese sebagai gabungan dari bawang, bawang putih, daging cincang, tomat, rempah-rempah, dan spaghetti. Anda memikirkannya sebagai satu hidangan lengkap. Ketika kita ingin menggabungkan nilai-nilai dalam Perl untuk menghasilkan satu nilai akhir, kita bisa menggunakan `reduce`. Mari kita lihat.

Kita mungkin ingin Perl menghitung rata-rata dari daftar angka. Misalnya, kita mungkin ingin menghitung rata-rata dari beberapa skor ujian. Ini dia beberapa angka skor:

```perl linenums="1"
my @scores = (74, 79, 89, 32, 79, 70, 32, 69, 76, 73, 88, 73, 82, 31);
```

Kita dapat menggunakan `reduce` untuk menjumlahkan skor-skor ini:

```perl linenums="1"
use List::Util 'reduce';
my $sum = reduce { $a + $b } @scores;
print "$sum\n";  # Output: 947
```

Fungsi `reduce` di sini melakukan perhitungan yang sama seperti contoh manual kita sebelumnya: ia mengembalikan nilai 947. Ini dilakukan dengan mengambil dua elemen pertama, lalu menambahkannya, kemudian mengambil hasil tersebut dan menambahkannya dengan elemen berikutnya, dan seterusnya hingga seluruh daftar diolah.

Setelah kita memiliki jumlah totalnya, kita tinggal membaginya dengan jumlah elemen dalam daftar untuk mendapatkan rata-rata:

```perl linenums="1"
my $average = $sum / @scores;
print "$average\n";  # Output: 67.64
```

Kita bisa menuliskan seluruh operasi ini dalam kode Perl dengan sangat mudah. Seperti yang kita lihat, `reduce` sangat berguna ketika kita ingin menggabungkan beberapa nilai menjadi satu.

Atau kita bisa mencoba menggunakan kalkulator, karena itu lebih sedikit rentan terhadap kesalahan. Cara kita melakukan perhitungan ini di kalkulator sama persis seperti di atas: kita akan menjumlahkan setiap angka, satu per satu, untuk menghitung jumlah total. Input kita ke kalkulator akan seperti ini:

```
74 + 79 + 89 + 32 + 79 + 70 + 32 + 69 + 76 + 73 + 88 + 73 + 82 + 31
```

Kalkulator kemudian akan memberi tahu kita bahwa jumlah angka-angka ini adalah 947, seperti yang seharusnya ditunjukkan oleh perhitungan manual kita. Silakan periksa ini di konsol re.pl Anda juga jika mau; setelah semua, ini hanya kalkulator super.

Setelah kita mendapatkan jumlah, kita perlu membagi jumlah tersebut dengan jumlah angka yang kita jumlahkan untuk mendapatkan rata-rata. Di sini, kita memiliki 14 angka. Jadi, rata-ratanya adalah 947 / 14, yang seharusnya diberitahukan oleh kalkulator atau prompt re.pl juga: 67.64285714285714. Kalkulator mungkin tidak memiliki banyak angka desimal. Jika kita ingin menuliskan seluruh operasi ini dalam kode Perl, itu akan sangat sederhana:

```perl linenums="1"
my $average = (74 + 79 + 89 + 32 + 79 + 70 + 32 + 69 + 76 + 73 + 88 + 73 + 82 + 31) / 14;
print "$average\n";  # Output: 67.64285714285714
```

Kita menjumlahkan semua angka, kemudian membaginya dengan berapa banyak skor yang kita miliki. Mudah! Ini mudah di sini karena hanya ada 14 angka. Tetapi bagaimana jika kita memiliki skor dari ratusan orang? Kita tidak ingin memasukkan semua ini ke dalam kalkulator atau prompt re.pl, kan? "Tidak mungkin!", kata Izzy. Tepat sekali! Jadi, mari kita lihat bagaimana kita bisa menggunakan `reduce` untuk menjumlahkan angka-angka tersebut, agar kita tidak perlu menghitung semuanya sendiri.

```perl linenums="1"
my @scores = (74, 79, 89, 32, 79, 70, 32, 69, 76, 73, 88, 73, 82, 31);
```

Fungsi `reduce` di sini melakukan perhitungan yang sama seperti prompt kita sebelumnya: ia mengembalikan 947. Ia melakukan ini dengan mengambil angka pertama, lalu menambahkan angka kedua, ketiga, keempat, dan seterusnya hingga mendapatkan jumlah total. Bagaimana cara kerjanya? Mari kita lihat langkah demi langkah.

Pertama, kita memberikan `reduce` daftar skor yang ingin kita jumlahkan. Kemudian kita memberikan fungsi lain yang mengambil dua argumen: `score` dan `sum`. Di dalam fungsi ini, kita menambahkan kedua argumen ini bersama-sama. Tapi nilai apa yang dimiliki `score` dan `sum` di dalam fungsi ini? Salah satu cara mudah untuk mengetahuinya adalah dengan membuat Perl mencetak nilai mereka setiap kali fungsi ini dalam `reduce` digunakan:

```perl linenums="1"
use List::Util 'reduce';
reduce { 
    print "Sum: $a, Score: $b\n"; 
    $a + $b; 
} @scores;
```

Meskipun urutan argumen di dalam fungsi adalah `score` dan `sum`, kita mencetaknya di sini sebagai `sum` dan `score` untuk alasan yang akan segera jelas. Ketika kita menjalankan varian baru dari fungsi `reduce` ini, outputnya akan seperti ini:

```
Sum: 74, Score: 79
Sum: 153, Score: 89
Sum: 242, Score: 32
Sum: 274, Score: 79
Sum: 353, Score: 70
Sum: 423, Score: 32
Sum: 455, Score: 69
Sum: 524, Score: 76
Sum: 600, Score: 73
Sum: 673, Score: 88
Sum: 761, Score: 73
Sum: 834, Score: 82
Sum: 916, Score: 31
Sum: 947
```

Angka pertama yang kita cetak adalah `sum` dan angka kedua adalah `score`. Jika kita melihat pada empat baris pertama dari output kita, kita akan melihat tiga angka: 74, 79, dan 153.

```
74
79
---
153
```

Jika kita melihat kembali pada definisi daftar skor kita, kita bisa melihat bahwa dua angka pertama adalah 74 dan 79. Jadi dari mana asalnya 153? Jawabannya mudah: 74 + 79 = 153. Jadi kita bisa mengetahui dari output di sini bahwa fungsi `reduce` kita mengambil item pertama dari daftar kita dan menjadikannya sebagai argumen awal untuk `sum` dalam fungsi kita. Item kedua kemudian menjadi argumen `score`. Dalam fungsi tersebut, kita menambahkan kedua nilai ini bersama-sama, dan itu menghasilkan 153. Fungsi `reduce` terus melanjutkan melalui angka-angka sisa dalam daftar, menambahkannya satu per satu hingga kita mendapatkan hasil akhir.

Jadi, itulah fungsi `reduce` yang hebat, atau setidaknya satu contohnya. Seperti yang Anda lihat, ini sangat berguna ketika kita ingin menggabungkan (atau mereduksi) beberapa item menjadi satu item.

##### Menjumlahkan Daftar

Saat ini, saya seharusnya menyebutkan satu fungsi lagi dalam alat bantu Enum yang disebut `sum/1`. Fungsi ini mengambil sebuah daftar dan menjumlahkan semua item di dalamnya, sama seperti fungsi `reduce/2` kita. Kedua fungsi ini identik dalam cara kerjanya:

```perl linenums="1"
my @scores = (74, 79, 89, 32, 79, 70, 32, 69, 76, 73, 88, 73, 82, 31);
print sum(@scores);  # Output: 947
```

```perl linenums="1"
use List::Util 'reduce';
print reduce { $a + $b } @scores;  # Output: 947
```

Jadi, jika Anda ingin menjumlahkan daftar angka, lebih baik menggunakan `sum/1` daripada menggunakan `reduce/2`, karena kode yang lebih sedikit. Jika Anda ingin melakukan operasi lain selain penjumlahan, seperti pengurangan, perkalian, pembagian, dan seterusnya, maka lebih baik menggunakan `reduce/2`.

##### Latihan

- Gunakan kombinasi `map` dan `String::Replace` untuk mengganti semua huruf 'e' dalam kata-kata ini dengan huruf lain yang Anda pilih:

```perl linenums="1"
use List::Util 'map';
use String::Replace;

my @words = ("a", "very", "fine", "collection", "of", "words", "enunciated");
my $replacement = 'x';  # Ganti dengan huruf pilihan Anda

my @replaced_words = map { replace($_, 'e', $replacement) } @words;
print join(", ", @replaced_words), "\n";
```

- Gunakan `reduce` untuk mengalikan angka-angka ini bersama-sama:

```perl linenums="1"
use List::Util 'reduce';

my @numbers = (5, 12, 9, 24, 9, 18);
my $product = reduce { $a * $b } @numbers;
print "$product\n";  # Output: 233280
``` 

Dengan latihan ini, Anda dapat lebih memahami penggunaan fungsi-fungsi dalam Perl yang setara dengan yang ada di Elixir.

---

next - 10. Working with maps
